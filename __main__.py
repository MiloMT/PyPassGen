"""Generates and stores a password or passwords given a set of parameters.

Using a series of CLI arguments and flags, this script will generate a
password or series of passwords seperate by new lines for user by the
user. The arguments allow which characters the password will use, and
how long each password will be. This module also uses the cryptography
library to encrypt password storage using a key generated by Fernet.

Typical Usage example:

    python __main__.py 10 5 -nsu
    python __main__.py 15 -sc

"""

import random
import sys
import string
import argparse
import pyperclip
import os

# import cryptography


def arg_check(
    var: string, arg1: string, arg1_desc: string, arg2: string, arg2_desc: string
) -> string:
    while var not in (arg1, arg2):
        var = input(
            f"Sorry, but that wasn't a valid input. Please enter"
            f"a [{arg1.upper()}] for {arg1_desc} or [{arg2.upper()}] "
            f"for {arg2_desc}: ",
        ).lower().strip()

    return var


def pass_gen(args: object, regex: string = None) -> list:
    password = ""
    pass_list = []
    char_list = [string.ascii_lowercase]

    # Flags to check for password character types.
    if args.upper:
        char_list.append(string.ascii_uppercase)
    if args.number:
        char_list.append(string.digits)
    if args.special:
        char_list.append(string.punctuation)

    if regex != None:
        # Number of password to generate.
        for _ in range(args.pass_num):
            # Password generator dependent on char_num and arg flags.
            for x in regex:
                match x:
                    case "l":
                        password += random.choice(string.ascii_lowercase)
                    case "u":
                        password += random.choice(string.ascii_uppercase)
                    case "n":
                        password += random.choice(string.digits)
                    case "s":
                        password += random.choice(string.punctuation)
                        
            pass_list.append(password)
            password = ""
    else:
        # Number of password to generate.
        for _ in range(args.pass_num):
            # Password generator dependent on char_num and arg flags.
            for _ in range(int(args.char_num)):
                password += random.choice(random.choice(char_list))

            pass_list.append(password)
            password = ""

    # Copy passwords if flag entered.
    if args.copy:
        pyperclip.copy("\n".join(pass_list))

    print("--------------------------------------------------")
    print("\n".join(pass_list))
    print("--------------------------------------------------")

    return pass_list


def store_pass(args: object, pass_list: list) -> bool:
    # Check if passwords.txt already exists in current directory.
    if os.path.isfile("passwords.txt") == True:
        # If it does, ask whether to overwrite or append passwords.
        print("There is already a passwords file in the current directory.")
        write_type = input(
            "Would you like to overwrite the file or append to "
            "this file? [W] or [A]: "
        )
        write_type = arg_check(write_type, "w", "overwrite", "a", "append")
        # Ask user to confirm overwrite as long as ignore option wasn't used.
        if write_type == "w" and args.force == False:
            overwrite_confirm = input(
                "This will overwrite your existing"
                " password file, are you sure? [Y] or [N]: "
            ).lower().strip()
            overwrite_confirm = arg_check(overwrite_confirm, "y", "yes", "n", "no")

        # Checks if force flag used or if user has confirmed overwrite.
        if write_type == "a" or args.force == True or overwrite_confirm == "y":
            with open("passwords.txt", write_type) as f:
                if write_type == "a":
                    f.write("\n")
                f.write("\n".join(pass_list))
            # Bool value for whether passwords were saved or not
            return True
        else:
            print("Save aborted")
            # Bool value for whether passwords were saved or not
            return False
    else:
        # If passwords.text doesn't exist, automatically create file.
        with open("passwords.txt", "w") as f:
            f.write("\n".join(pass_list))
        print(
            "Your passwords have been saved in the 'passwords.txt'",
            "file in the current directory",
        )
        # Bool value for whether passwords were saved or not
        return True


def encrypt_pass(args: object, pass_list: list) -> None:
    # Ask whether to encrypt password txt file
    print("Testing")
    pass


def retrieve_pass(args):
    if os.path.isfile("passwords.txt"):
        print("Passwords in passwords.txt:")
        print("--------------------------------------------------")
        with open("passwords.txt", "r") as f:
            for line in f:
                print(line, end="")
        print("\n--------------------------------------------------")
    else:
        print("There is no password.txt file in the current directory.")


def regex_gen() -> string:
    print(
        "You've selected to create an expression to use for password generation.\n"
        "A password expression is created by using a sequence of characters in a\n"
        "designated order. The characters to use are below:\n\n - [l] lowercase letter\n"
        " - [u] uppercase letter\n - [n] digit\n - [s] special character\n\n"
        "Please refer to the help guide for expression examples.\n"
    )
    regex = input("Please input a compatible expression: ").lower().replace(" ", "")
    char_list = []
    for x in regex:
        if x not in ("l", "u", "n", "s"):
            char_list.append(x)
    while len(char_list) != 0:
        char_list = []
        print(
            "Your expression is not valid. The invalid characters are:\n"
            f"{"\n - ".join(char_list)}\n"
        )
        regex = input("Please try to input another expression: ").lower().replace(" ", "")
        for x in regex:
            if x not in ("l", "u", "n", "s"):
                char_list.append(x)
    return regex

def main(args):
    if args.view:
        retrieve_pass(args)
    else:
        if args.regex:
            regex = regex_gen()
            print("\nPasswords Generated:")
            pass_list = pass_gen(args, regex)
        else: 
            print("Passwords Generated:")
            pass_list = pass_gen(args)
        
        save_confirm = input(
            "Would you like to save your generated passwords? [Y] or [N]: "
        ).lower().strip()
        save_confirm = arg_check(save_confirm, "y", "yes", "n", "no")

        if save_confirm == "y":
            is_saved = store_pass(args, pass_list)

        # Only asks to encrypt is passwords were saved
        if is_saved == True:
            encrypt_confirm = input(
                "Would you like to encrypt your saved passwords? [Y] or [N]: "
            ).lower().strip()
            encrypt_confirm = arg_check(encrypt_confirm, "y", "yes", "n", "no")

            if encrypt_confirm == "y":
                encrypt_pass(args, pass_list)


if __name__ == "__main__":
    # Instantiate argparse
    parser = argparse.ArgumentParser(
        description="Generates a password or series of passwords given a "
        "set of parameters"
    )

    # List of positional arguments
    parser.add_argument(
        "char_num",
        metavar="Num_of_Chars",
        nargs="?",
        default = 10,
        type=int,
        help="Optionally enter a number of characters in password. (default: 10)",
    )
    parser.add_argument(
        "pass_num",
        metavar="Num_of_Passwords",
        nargs="?",
        default=1,
        type=int,
        help="Optionally create a number of passwords. (default: 1)",
    )

    # List of options
    parser.add_argument(
        "-c",
        "--copy",
        help="Copies the password to the clipboard once generated",
        action="store_true",
    )
    parser.add_argument(
        "-f",
        "--force",
        help="Forces overwrite so app ignores overwrite confirmation",
        action="store_true",
    )
    parser.add_argument(
        "-n",
        "--number",
        help="Adds numbers to password generation",
        action="store_true",
    )
    parser.add_argument(
        "-r",
        "--regex",
        help="Lets the generator know that you want to create an"
        " expression to control the password generation",
        action="store_true",
    )
    parser.add_argument(
        "-s",
        "--special",
        help="Adds special characters to password generation",
        action="store_true",
    )
    parser.add_argument(
        "-u",
        "--upper",
        help="Adds uppercase letters to password generation",
        action="store_true",
    )
    parser.add_argument(
        "--view",
        help="Instead of generating passwords, prints out passwords to terminal",
        action="store_true",
    )

    # Parse the passed arguments
    args = parser.parse_args()

    main(args)